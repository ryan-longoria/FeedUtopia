// src/loaders.ts
var countryDirMap = null;
var stateDirMaps = /* @__PURE__ */ new Map();
function isNodeEnvironment() {
  return typeof process !== "undefined" && process.versions != null && process.versions.node != null;
}
async function importNodeModule(moduleName) {
  if (!isNodeEnvironment()) {
    throw new Error(`Module ${moduleName} is not available in browser environment`);
  }
  switch (moduleName) {
    case "fs":
      return import(
        /* webpackIgnore: true */
        'fs'
      );
    case "path":
      return import(
        /* webpackIgnore: true */
        'path'
      );
    case "url":
      return import(
        /* webpackIgnore: true */
        'url'
      );
    default:
      throw new Error(`Unsupported module: ${moduleName}`);
  }
}
async function loadJSON(path) {
  try {
    const module = await import(path);
    return module.default;
  } catch (error) {
    if (!isNodeEnvironment()) {
      throw error;
    }
    try {
      const fs = await importNodeModule("fs");
      const pathModule = await importNodeModule("path");
      const { fileURLToPath } = await importNodeModule("url");
      let basePath;
      if (typeof __dirname !== "undefined") {
        basePath = __dirname;
      } else {
        basePath = pathModule.dirname(fileURLToPath(import.meta.url));
      }
      const possiblePaths = [
        pathModule.join(basePath, path),
        pathModule.join(basePath, "..", path),
        // In case dist structure is different
        pathModule.join(process.cwd(), "node_modules", "@countrystatecity", "countries", "dist", path)
        // Vercel/serverless
      ];
      let data = null;
      let lastError = null;
      for (const fullPath of possiblePaths) {
        try {
          data = fs.readFileSync(fullPath, "utf-8");
          break;
        } catch (readError) {
          lastError = readError;
          continue;
        }
      }
      if (data === null) {
        const err = new Error(`Failed to load JSON file: ${path}. Tried paths: ${possiblePaths.join(", ")}`);
        err.code = "MODULE_NOT_FOUND";
        err.originalError = lastError;
        throw err;
      }
      return JSON.parse(data);
    } catch (fsError) {
      throw error;
    }
  }
}
async function getCountryDirName(countryCode) {
  if (!countryDirMap) {
    if (!isNodeEnvironment()) {
      throw new Error("Directory scanning is only available in Node.js environment");
    }
    const fs = await importNodeModule("fs");
    const pathModule = await importNodeModule("path");
    let basePath;
    if (typeof __dirname !== "undefined") {
      basePath = __dirname;
    } else {
      const { fileURLToPath } = await importNodeModule("url");
      basePath = pathModule.dirname(fileURLToPath(import.meta.url));
    }
    const dataDir = pathModule.join(basePath, "data");
    const dirs = fs.readdirSync(dataDir, { withFileTypes: true }).filter((d) => d.isDirectory()).map((d) => d.name);
    countryDirMap = /* @__PURE__ */ new Map();
    for (const dir of dirs) {
      const parts = dir.split("-");
      const iso2 = parts[parts.length - 1];
      countryDirMap.set(iso2, dir);
    }
  }
  return countryDirMap.get(countryCode) || null;
}
async function getStateDirName(countryCode, stateCode) {
  const countryDir = await getCountryDirName(countryCode);
  if (!countryDir) return null;
  if (!stateDirMaps.has(countryCode)) {
    if (!isNodeEnvironment()) {
      throw new Error("Directory scanning is only available in Node.js environment");
    }
    const fs = await importNodeModule("fs");
    const pathModule = await importNodeModule("path");
    let basePath;
    if (typeof __dirname !== "undefined") {
      basePath = __dirname;
    } else {
      const { fileURLToPath } = await importNodeModule("url");
      basePath = pathModule.dirname(fileURLToPath(import.meta.url));
    }
    const countryPath = pathModule.join(basePath, "data", countryDir);
    const dirs = fs.readdirSync(countryPath, { withFileTypes: true }).filter((d) => d.isDirectory()).map((d) => d.name);
    const stateMap = /* @__PURE__ */ new Map();
    for (const dir of dirs) {
      const parts = dir.split("-");
      const code = parts[parts.length - 1];
      stateMap.set(code, dir);
    }
    stateDirMaps.set(countryCode, stateMap);
  }
  return stateDirMaps.get(countryCode)?.get(stateCode) || null;
}
async function getCountries() {
  return loadJSON("./data/countries.json");
}
async function getCountryByCode(countryCode) {
  try {
    const countryDir = await getCountryDirName(countryCode);
    if (!countryDir) return null;
    return await loadJSON(`./data/${countryDir}/meta.json`);
  } catch (error) {
    return null;
  }
}
async function getStatesOfCountry(countryCode) {
  try {
    const countryDir = await getCountryDirName(countryCode);
    if (!countryDir) return [];
    return await loadJSON(`./data/${countryDir}/states.json`);
  } catch (error) {
    return [];
  }
}
async function getStateByCode(countryCode, stateCode) {
  const states = await getStatesOfCountry(countryCode);
  const state = states.find((s) => s.iso2 === stateCode);
  return state || null;
}
async function getCitiesOfState(countryCode, stateCode) {
  try {
    const countryDir = await getCountryDirName(countryCode);
    if (!countryDir) return [];
    const stateDir = await getStateDirName(countryCode, stateCode);
    if (!stateDir) return [];
    return await loadJSON(`./data/${countryDir}/${stateDir}/cities.json`);
  } catch (error) {
    return [];
  }
}
async function getAllCitiesOfCountry(countryCode) {
  const states = await getStatesOfCountry(countryCode);
  const allCities = [];
  for (const state of states) {
    const cities = await getCitiesOfState(countryCode, state.iso2);
    allCities.push(...cities);
  }
  return allCities;
}
async function getAllCitiesInWorld() {
  const countries = await getCountries();
  const allCities = [];
  for (const country of countries) {
    const cities = await getAllCitiesOfCountry(country.iso2);
    allCities.push(...cities);
  }
  return allCities;
}
async function getCityById(countryCode, stateCode, cityId) {
  const cities = await getCitiesOfState(countryCode, stateCode);
  const city = cities.find((c) => c.id === cityId);
  return city || null;
}

// src/utils.ts
async function isValidCountryCode(countryCode) {
  const countries = await getCountries();
  return countries.some((c) => c.iso2 === countryCode);
}
async function isValidStateCode(countryCode, stateCode) {
  const states = await getStatesOfCountry(countryCode);
  return states.some((s) => s.iso2 === stateCode);
}
async function searchCitiesByName(countryCode, stateCode, searchTerm) {
  const cities = await getCitiesOfState(countryCode, stateCode);
  const lowerSearchTerm = searchTerm.toLowerCase();
  return cities.filter((city) => city.name.toLowerCase().includes(lowerSearchTerm));
}
async function getCountryNameByCode(countryCode) {
  const countries = await getCountries();
  const country = countries.find((c) => c.iso2 === countryCode);
  return country ? country.name : null;
}
async function getStateNameByCode(countryCode, stateCode) {
  const states = await getStatesOfCountry(countryCode);
  const state = states.find((s) => s.iso2 === stateCode);
  return state ? state.name : null;
}
async function getTimezoneForCity(countryCode, stateCode, cityName) {
  const cities = await getCitiesOfState(countryCode, stateCode);
  const city = cities.find((c) => c.name === cityName);
  return city ? city.timezone : null;
}
async function getCountryTimezones(countryCode) {
  const countryMeta = await getCountryByCode(countryCode);
  if (!countryMeta || !countryMeta.timezones) {
    return [];
  }
  return countryMeta.timezones.map((tz) => tz.zoneName);
}

export { getCountries as default, getAllCitiesInWorld, getAllCitiesOfCountry, getCitiesOfState, getCityById, getCountries, getCountryByCode, getCountryNameByCode, getCountryTimezones, getStateByCode, getStateNameByCode, getStatesOfCountry, getTimezoneForCity, isValidCountryCode, isValidStateCode, searchCitiesByName };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map