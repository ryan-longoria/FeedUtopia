<dialog id="auth-modal" class="card" style="max-width:520px">
  <h2>Welcome</h2>
  <p class="muted">Log in or create an account to continue.</p>

  <div class="mt-3" role="tablist" aria-label="Auth tabs" style="display:flex; gap:8px">
    <button class="btn small" id="tab-login"  type="button" aria-selected="true">Log In</button>
    <button class="btn small secondary" id="tab-signup" type="button" aria-selected="false">Create Account</button>
  </div>

  <!-- Login -->
  <form id="form-login" class="mt-3">
    <label>Email</label>
    <input class="input" name="email" type="email" autocomplete="email" required />
    <label>Password</label>
    <input class="input" name="password" type="password" autocomplete="current-password" required />
    <button class="btn mt-3" type="submit">Log In</button>
    <p class="muted mt-2" style="font-size:12px">By continuing you agree to our <a href="terms.html">Terms</a> and <a href="privacy.html">Privacy Policy</a>.</p>
  </form>

  <!-- Sign Up -->
  <form id="form-signup" class="mt-3 hidden">
    <label>Email</label>
    <input class="input" name="email" type="email" autocomplete="email" required />

    <label>Password</label>
    <input class="input" name="password" type="password" autocomplete="new-password" required />

    <label>Role</label>
    <select class="input" name="role" id="signup-role" required>
      <option value="Wrestler">Wrestler</option>
      <option value="Promoter">Promoter</option>
    </select>

    <!-- Wrestler fields -->
    <fieldset id="wrestler-fields" class="mt-3">
      <legend class="muted" style="margin-bottom:6px">Wrestler details</legend>
      <label>First name</label>
      <input class="input" name="given_name" required />
      <label>Last name</label>
      <input class="input" name="family_name" required />
      <label>Stage name</label>
      <input class="input" name="stageName" required />
      <label>Date of birth (YYYY-MM-DD)</label>
      <input
        class="input"
        name="dob"
        type="date"
        required
        pattern="\d{4}-\d{2}-\d{2}"
        max="<?= new Date().toISOString().slice(0,10) /* or hard-code for static site */ ?>"
      />
      <div class="grid cols-3" style="gap:8px">
        <div>
          <label>City</label>
          <input class="input" name="city" required />
        </div>
        <div>
          <label>State/Region</label>
          <input class="input" name="region" required />
        </div>
        <div>
          <label>Country</label>
          <input class="input" name="country" required />
        </div>
      </div>
    </fieldset>

    <!-- Promoter fields -->
    <fieldset id="promoter-fields" class="mt-3 hidden">
      <legend class="muted" style="margin-bottom:6px">Promotion details</legend>
      <label>Promotion / Org name</label>
      <input class="input" name="orgName" />
      <label>Full address</label>
      <input class="input" name="address" />
    </fieldset>

    <button class="btn mt-3" type="submit">Create Account</button>
    <p class="muted mt-2" style="font-size:12px">We’ll email you a confirmation code.</p>
  </form>

  <!-- Confirm -->
  <form id="form-confirm" class="mt-3 hidden">
    <label>Confirmation Code</label>
    <input class="input" name="code" inputmode="numeric" autocomplete="one-time-code" required />
    <button class="btn mt-3" type="submit">Confirm</button>
    <button class="btn small secondary" id="resend-code" type="button">Resend code</button>
  </form>

  <div class="mt-3" style="display:flex; gap:8px; justify-content:flex-end">
    <button class="btn secondary" type="button" id="auth-close">Close</button>
  </div>
</dialog>

<script type="module">
  // Use your bridge so config is centralized
  import {
    signIn,
    confirmSignIn,
    signUp,
    confirmSignUp,
    resendSignUpCode,
    signOut,
  } from '/js/auth-bridge.js';

  // ---- one-time wiring guard (prevents double event listeners) ----
  if (window._wuAuthWired) {
    // already initialized (avoids duplicate handlers that spam MFA)
    console.debug('[auth] already wired, skipping');
  } else {
    window._wuAuthWired = true;

    const dlg      = document.getElementById('auth-modal');
    const tabLogin = document.getElementById('tab-login');
    const tabSignup= document.getElementById('tab-signup');
    const fLogin   = document.getElementById('form-login');
    const fSignup  = document.getElementById('form-signup');
    const fConfirm = document.getElementById('form-confirm');

    const roleSel  = document.getElementById('signup-role');
    const wf       = document.getElementById('wrestler-fields');
    const pf       = document.getElementById('promoter-fields');

    // keep minimal in-memory state
    let signupEmailForConfirm = '';
    let signupPasswordCache   = '';
    let submitLock = false; // debounce to avoid double calls
    const withSubmitLock = (fn) => async (...args) => {
      if (submitLock) return;
      try { submitLock = true; await fn(...args); }
      finally { submitLock = false; }
    };

    // small helpers
    const show   = (el) => el && el.classList.remove('hidden');
    const hide   = (el) => el && el.classList.add('hidden');
    const toast  = (msg) => { try { alert(msg); } catch {} };

    function showLogin() {
      tabLogin?.setAttribute('aria-selected', 'true');
      tabSignup?.setAttribute('aria-selected', 'false');
      show(fLogin); hide(fSignup); hide(fConfirm);
    }

    function showSignup(intentRole) {
      tabLogin?.setAttribute('aria-selected', 'false');
      tabSignup?.setAttribute('aria-selected', 'true');
      hide(fLogin); show(fSignup); hide(fConfirm);
      if (intentRole === 'promoter') roleSel.value = 'Promoter';
      if (intentRole === 'wrestler') roleSel.value = 'Wrestler';
      onRoleChange();
    }

    function showConfirmFor(email, { mode } = {}) {
      signupEmailForConfirm = email || signupEmailForConfirm || '';
      if (!signupEmailForConfirm) {
        toast('We need your email to confirm. Please sign up or log in again.');
        showSignup();
        return;
      }
      hide(fLogin); hide(fSignup); show(fConfirm);
      fConfirm.dataset.mode = mode || '';
    }

    function onRoleChange() {
      if (!roleSel || !wf || !pf) return;
      const isW = roleSel.value === 'Wrestler';
      wf.classList.toggle('hidden', !isW);
      pf.classList.toggle('hidden',  isW);
      // toggle requireds so the browser helps you (Lambda still enforces server-side)
      wf.querySelectorAll('input').forEach(i => i.required = isW);
      pf.querySelectorAll('input').forEach(i => i.required = !isW);
    }

    roleSel?.addEventListener('change', onRoleChange);
    onRoleChange();

    // Tabs
    tabLogin?.addEventListener('click', showLogin);
    tabSignup?.addEventListener('click', () => showSignup());

    // Close dialog
    document.getElementById('auth-close')?.addEventListener('click', () => {
      dlg.close();
      // clear ephemeral state on close
      signupEmailForConfirm = '';
      signupPasswordCache = '';
      fConfirm?.reset?.();
    });

    // Public hook: open modal with optional intent
    window.addEventListener('auth:open', (e) => {
      dlg.showModal();
      const intent = (e?.detail?.intent || '').toString().toLowerCase();
      if (intent === 'promoter' || intent === 'wrestler') showSignup(intent);
      else showLogin();
    });

    // Also wire your nav “Log In” button
    document.getElementById('login-btn')?.addEventListener('click', (e) => {
      e.preventDefault();
      dlg.showModal();
      showLogin();
    });

    // --------------------------
    // Sign Up
    // --------------------------
    fSignup?.addEventListener('submit', withSubmitLock(async (e) => {
      e.preventDefault();
      const fd = new FormData(fSignup);
      const email    = String(fd.get('email') || '').trim();
      const password = String(fd.get('password') || '');
      const role     = String(fd.get('role') || 'Wrestler');

      const isW = role === 'Wrestler';

      // Collect attributes, but never send empty strings for optional ones
      const ua = {
        email,
        'custom:role': role,
      };

      if (isW) {
        const given      = String(fd.get('given_name') || '').trim();
        const family     = String(fd.get('family_name') || '').trim();
        const stage      = String(fd.get('stageName') || '').trim();
        const dob        = String(fd.get('dob') || '').trim();       // <input type="date"> gives YYYY-MM-DD
        const city       = String(fd.get('city') || '').trim();
        const region     = String(fd.get('region') || '').trim();
        const country    = String(fd.get('country') || '').trim();
        Object.assign(ua, {
          given_name: given,
          family_name: family,
          'custom:stageName': stage,
          'custom:dob': dob,
          'custom:city': city,
          'custom:region': region,
          'custom:country': country,
        });
      } else {
        const orgName  = String(fd.get('orgName') || '').trim();
        const address  = String(fd.get('address') || '').trim();
        if (orgName) ua['custom:orgName'] = orgName;
        if (address) ua['custom:address'] = address; // don’t send empty string (avoids min-length schema errors)
      }

      try {
        await signUp({
          username: email,
          password,
          options: { userAttributes: ua }
        });

        // remember for confirm + possible auto sign-in
        signupEmailForConfirm = email;
        signupPasswordCache   = password;

        showConfirmFor(email, { mode: 'signup' });
        toast('We emailed you a verification code.');
      } catch (err) {
        console.error('[auth] signUp error', err);
        // Friendly messages for common cases
        const msg = err?.name === 'UsernameExistsException'
          ? 'An account with this email already exists.'
          : (err?.message || 'Sign up failed');
        toast(msg);
      }
    }));

    // --------------------------
    // Resend sign-up code
    // --------------------------
    document.getElementById('resend-code')?.addEventListener('click', withSubmitLock(async () => {
      if (!signupEmailForConfirm) {
        toast('Open the Create Account tab and enter your email first.');
        showSignup();
        return;
      }
      try {
        await resendSignUpCode({ username: signupEmailForConfirm });
        toast('Verification code resent.');
      } catch (err) {
        console.error('[auth] resendSignUpCode error', err);
        toast(err?.message || 'Could not resend code.');
      }
    }));

    // --------------------------
    // Confirm (sign-up OR MFA)
    // --------------------------
    fConfirm?.addEventListener('submit', withSubmitLock(async (e) => {
      e.preventDefault();
      const code = String(new FormData(fConfirm).get('code') || '').trim();

      // MFA branch
      if (fConfirm.dataset.mfa === 'true') {
        try {
          await confirmSignIn({ challengeResponse: code });
          // done – user is signed in now
          fConfirm.dataset.mfa = '';
          dlg.close();
          toast('You are signed in.');
          return;
        } catch (err) {
          console.error('[auth] confirmSignIn error', err);
          toast(err?.message || 'MFA confirmation failed.');
          return;
        }
      }

      // Sign-up confirmation branch
      if (!signupEmailForConfirm) {
        toast('We lost the email for confirmation; please sign up or log in again.');
        showSignup();
        return;
      }
      try {
        await confirmSignUp({ username: signupEmailForConfirm, confirmationCode: code });
        toast('Email confirmed! Signing you in…');

        // Auto sign-in after confirming (optional)
        if (signupPasswordCache) {
          try { await signIn({ username: signupEmailForConfirm, password: signupPasswordCache }); }
          catch (e2) { /* ignore – user can click Log In */ }
        }
        dlg.close();
      } catch (err) {
        console.error('[auth] confirmSignUp error', err);
        let m = err?.message || 'Confirmation failed.';
        if (err?.name === 'ExpiredCodeException') m = 'Code expired. Click “Resend code”.';
        toast(m);
      }
    }));

    // --------------------------
    // Log In (handles Amplify v6 nextStep cleanly)
    // --------------------------
    fLogin?.addEventListener('submit', withSubmitLock(async (e) => {
      e.preventDefault();
      const fd = new FormData(fLogin);
      const email    = String(fd.get('email') || '').trim();
      const password = String(fd.get('password') || '');

      try {
        const { nextStep } = await signIn({
          username: email,
          password,
          options: {
            authFlowType: 'USER_SRP_AUTH',
            preferredChallenge: 'EMAIL_OTP', // ask Cognito to use email codes
          },
        });

        switch (nextStep.signInStep) {
          case 'DONE': {
            dlg.close();
            toast('Logged in!');
            break;
          }

          case 'CONFIRM_SIGN_UP': {
            // account exists but not verified
            showConfirmFor(email, { mode: 'signup' });
            toast('Enter the verification code we just emailed you.');
            break;
          }

          case 'CONTINUE_SIGN_IN_WITH_MFA_SELECTION': {
            // choose EMAIL once; this triggers a **single** OTP email
            const choice = nextStep.allowedMFATypes?.includes('EMAIL')
              ? 'EMAIL'
              : nextStep.allowedMFATypes?.[0];
            await confirmSignIn({ challengeResponse: choice });
            // show the MFA code form
            showConfirmFor(email, { mode: '' });
            fConfirm.dataset.mfa = 'true';
            toast('Enter the code we emailed you.');
            break;
          }

          case 'CONFIRM_SIGN_IN_WITH_EMAIL_CODE':
          case 'CONFIRM_SIGN_IN_WITH_SMS_CODE':
          case 'CONFIRM_SIGN_IN_WITH_TOTP_CODE': {
            // code already sent by Cognito; just collect it
            showConfirmFor(email, { mode: '' });
            fConfirm.dataset.mfa = 'true';
            toast('Enter the code we emailed you.');
            break;
          }

          case 'CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION': {
            // choose PASSWORD; Cognito will follow with an EMAIL_OTP challenge
            await confirmSignIn({ challengeResponse: 'PASSWORD_SRP' });
            showConfirmFor(email, { mode: '' });
            fConfirm.dataset.mfa = 'true';
            toast('Enter the code we emailed you.');
            break;
          }

          case 'CONFIRM_SIGN_IN_WITH_NEW_PASSWORD_REQUIRED': {
            toast('A new password is required (UI not implemented yet).');
            break;
          }

          default: {
            console.warn('[auth] unhandled nextStep', nextStep);
            toast('Additional verification required (not implemented).');
          }
        }
      } catch (err) {
        console.error('[auth] signIn error', err);
        let m = err?.message || 'Login failed.';
        if (err?.name === 'LimitExceededException') m = 'Too many attempts. Please wait a minute and try again.';
        toast(m);
      }
    }));

    // --------------------------
    // Log Out
    // --------------------------
    document.addEventListener('click', async (e) => {
      const btn = e.target.closest('#logout-btn');
      if (!btn) return;
      e.preventDefault();
      try { await signOut(); toast('Logged out.'); }
      catch (err) { console.error('[auth] signOut error', err); toast('Logout failed.'); }
    });
  }
</script>

